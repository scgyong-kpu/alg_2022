# prim 과제했을 때 사용한 edge list 준비
# 파일 이름은 tm_03_학번.py

# class 02
n_vertices = 19
edges = [
  (0, 1, 565), (0, 4, 473), (0, 6, 124), (0, 18, 448), (1, 4, 166), 
  (1, 6, 257), (1, 7, 532), (1, 16, 323), (2, 5, 169), (2, 8, 172), 
  (2, 11, 255), (2, 15, 526), (3, 8, 154), (3, 11, 381), (3, 12, 240), 
  (3, 13, 464), (3, 15, 375), (3, 16, 220), (3, 17, 318), (4, 10, 280), 
  (5, 9, 374), (5, 13, 484), (6, 10, 179), (6, 13, 445), (6, 17, 93), 
  (7, 13, 211), (7, 17, 313), (9, 12, 47), (9, 13, 239), (9, 14, 217), 
  (11, 14, 430), (12, 13, 305), (12, 14, 228), (15, 18, 249), (17, 18, 386)
]

# # class 01
# n_vertices = 18
# edges = [
#   (0, 9, 210), (0, 13, 498), (0, 16, 606), (1, 2, 203), (1, 8, 217), 
#   (1, 16, 537), (2, 8, 322), (2, 16, 269), (3, 4, 189), (3, 7, 534), 
#   (3, 8, 466), (3, 11, 371), (3, 12, 284), (3, 17, 407), (4, 7, 193), 
#   (4, 11, 273), (4, 12, 181), (4, 15, 316), (5, 6, 224), (5, 14, 178), 
#   (5, 17, 628), (6, 10, 202), (6, 11, 448), (6, 17, 272), (7, 11, 142), 
#   (7, 12, 141), (7, 15, 249), (9, 13, 457), (9, 16, 281), (10, 17, 405), 
#   (11, 12, 215), (11, 17, 176), (12, 15, 255), (12, 17, 373), (13, 14, 241), 
#   (13, 16, 265)
# ]

# class 04
n_vertices = 18
edges = [
  (0, 1, 686), (0, 2, 429), (0, 5, 232), (0, 9, 319), (0, 13, 193), 
  (1, 8, 180), (1, 10, 345), (1, 11, 100), (1, 13, 302), (1, 17, 374), 
  (2, 10, 83), (2, 11, 298), (2, 12, 730), (2, 17, 96), (3, 12, 332), 
  (3, 13, 494), (3, 17, 342), (4, 7, 378), (4, 8, 374), (4, 14, 235), 
  (4, 15, 214), (5, 12, 320), (5, 17, 302), (6, 15, 208), (6, 16, 190), 
  (7, 15, 240), (8, 11, 194), (8, 13, 709), (9, 12, 62), (10, 11, 254), 
  (10, 13, 249), (10, 17, 97), (11, 14, 323), (12, 13, 140), (12, 14, 572), 
  (12, 17, 494), (13, 14, 383), (13, 17, 479), (14, 16, 694), (15, 16, 392)
]


# 0. union-find 구현
roots = [ x for x in range(n_vertices) ]
def union(u, v):
  global roots
  uroot = find_root(u)
  vroot = find_root(v)
  if uroot > vroot:
    uroot,vroot = vroot,uroot
  roots[vroot] = uroot
def find_root(u):
  if u != roots[u]:
    roots[u] = find_root(roots[u]) # 경로압축
  return roots[u]

# 1. Kruskal Algorithm 으로 MST 구하기
edges.sort(key=lambda e: e[2]) # edge list 를 가중치로 정렬한다
mst = []
for u, v, w in edges:
  if find_root(u) == find_root(v): continue
  union(u, v)
  mst.append([u,v,w])
  if len(mst) >= n_vertices - 1: break

print(mst)
# [[0, 7, 59], [4, 8, 82], [3, 4, 100], [5, 6, 119], [1, 11, 125], 
#  [9, 10, 150], [1, 5, 150], [4, 10, 164], [2, 10, 166], [6, 7, 169], 
#  [0, 9, 372]]

# 2. Sequence 구하기
adjs = [ [] for _ in range(n_vertices) ]
for u,v,w in mst:
  adjs[u].append(v)
  adjs[v].append(u)
print(adjs)
# [[7, 9], [11, 5], [10], [4], [8, 3, 10], 
#  [6, 1], [5, 7], [0, 6], [4], [10, 0], 
#  [9, 4, 2], [1]]

current = start_index = 4
seq = [ start_index ]
while adjs[current]:
  for i in range(len(adjs[current])):# 
    v = adjs[current][i]
    if not v in seq:
      at = i
      break
  else:
    at = 0
    v = adjs[current][0]

  adjs[current].pop(at)
  seq.append(v)
  current = v
print(seq)
# [3, 4, 8, 4, 10, 9, 0, 7, 6, 5, 1, 11, 1, 5, 6, 7, 0, 9, 10, 2, 10, 4, 3]

# 3. 중복 제거하기
idx = 0
visited = set()
while idx < len(seq):
  v = seq[idx]
  if v in visited:
    seq.pop(idx)
  else:
    idx += 1
    visited.add(v)
seq.append(start_index)
print(seq)
# [3, 4, 8, 10, 9, 0, 7, 6, 5, 1, 11, 2, 3]
